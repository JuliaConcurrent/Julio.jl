var documenterSearchIndex = {"docs":
[{"location":"tutorials/select/","page":"Select","title":"Select","text":"EditURL = \"https://github.com/tkf/Julio.jl/blob/master/examples/select.jl\"","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"note: Note\nJulio.jl is still work-in-progress.","category":"page"},{"location":"tutorials/select/#man-select","page":"Select","title":"Select","text":"","category":"section"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"using Julio: Julio, Events\nusing Test","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"Julio.select can be used for executing exactly one ready event from a set of events.","category":"page"},{"location":"tutorials/select/#Selecting-a-queue","page":"Select","title":"Selecting a queue","text":"","category":"section"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"function test_simple_select()","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"To demonstrate how Julio.select works, suppose that we have multiple queues and waiting for an element from them.","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"    qin1, qout1 = Julio.queue()  # input/output endpoints for the first queue\n    qin2, qout2 = Julio.queue()  # input/output endpoints for the second queue","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"Suppose there is an element in the second queue:","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"    put!(qin2, 222)","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"Then waiting on take! event of an empty queue and a nonempty queue does not block. It executes the take! event on the nonempty queue:","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"    selected = nothing\n    Julio.select(\n        (take!, qout1) => item -> begin\n            selected = item\n        end,\n        (take!, qout2) => item -> begin\n            selected = item\n        end,\n    )\n    @test selected == 222","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"end","category":"page"},{"location":"tutorials/select/#Selecting-an-arbitrary-event","page":"Select","title":"Selecting an arbitrary event","text":"","category":"section"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"Julio.select can also be used with various events.","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"function test_mixed_select()","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"It supports, for example, unbuffered channel:","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"    chi, cho = Julio.channel()","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"...and read/write on IO objects such as a pipe:","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"    Julio.open(`echo \"hello\"`) do output","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"...and acquiring locks:","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"        lck = Julio.Lock()","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"When the Base API $f has keyword arguments, you can use Julio.Events.$f to create an event.  Note that ($f, args...) is equivalent to Julio.Events.$f(args...).","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"        selected = nothing\n        Julio.select(\n            Events.readline(output; keep = true) => item -> begin\n                selected = item\n            end,\n            Events.lock(lck) => _ -> begin\n                unlock(lck)\n                selected = :lock\n            end,\n            (put!, chi, 1) => _ -> begin\n                selected = :put_1\n            end,\n        )","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"In the above example, since the output pipe and the lock are both ready, Julio.select can select any one of them. However, since there is no other task take!ing the element from the channel cho, the put! event can not be selected.","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"        @test selected in (\"hello\\n\", :lock)","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"If Events.lock(lck) was selected, the output is not consumed:","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"        if selected === :lock\n            @test readline(output) == \"hello\"\n        end","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"    end\nend","category":"page"},{"location":"tutorials/select/#ex-bounding-search","page":"Select","title":"Example: bounding search results","text":"","category":"section"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"Suppose we need to move at least minitems items from one channel to another while filtering them using a predicate function f. Furthermore, we don't want to loose any items. That is to say, once an item is taken from the input channel, it must be put into the output channel (unless f evaluates to false).  Note that the we cannot use the cancel scope (naively) due to the last requirement; i.e., it is not correct to cancel the task when it's blocked while putting the item to the output channel. While we can still use the cancel scope by surrounding post-take! code in a Julio.shield block, the folowing code demonstrates more straightforward approach based on Julio.select.","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"To setup cancellation specific to one event (take!), we can use explicit \"cancellation token\" and combine it with the original event.","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"using Julio: maybetake!, tryput!\n\nfunction channel_filter!(f, output, input, minitems; ntasks = 4 * Threads.nthreads())\n    nitems = Threads.Atomic{Int}(0)\n    done = Julio.Promise{Nothing}()  # cancellation token\n    Julio.withtaskgroup() do tg\n        for _ in 1:ntasks\n            Julio.spawn!(tg) do\n                while true\n                    m = Julio.select(\n                        (fetch, done) => Returns(nothing),  # return nothing when done\n                        (maybetake!, input),  # return Some(x) if we took x\n                    )\n                    x = @something(m, break)  # break if done\n                    if f(x)\n                        put!(output, x)\n                        # If enough items have been sent, signal other tasks to finish.\n                        if Threads.atomic_add!(nitems, 1) + 1 >= minitems\n                            tryput!(done, nothing)\n                            break\n                        end\n                    end\n                end\n            end\n        end\n    end\nend","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"In the above example, we use (Julio.maybetake!, input) event instead of (take!, input) event.  This is for handling the case input is closed. That is to say, m === nothing if input is closed or tryput!(done, nothing) has been executed.","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"function test_channel_filter()\n    Julio.withtaskgroup() do tg\n        ie1, oe1 = Julio.channel()\n        ie2, oe2 = Julio.channel()\n        Julio.spawn!(tg) do\n            try\n                for i in 1:15\n                    put!(ie1, i)\n                end\n            finally\n                close(ie1)\n            end\n        end\n        Julio.spawn!(tg) do\n            try\n                channel_filter!(isodd, ie2, oe1, 3; ntasks = 2)\n            finally\n                close(ie2)\n            end\n        end\n        try\n            out2 = collect(oe2)\n            out1 = collect(oe1)\n            sort!(out2)\n            sort!(out1)\n            @test length(out2) >= 3  # `channel_filter!` produced at least 3 elements\n            @test out2 == (1:length(out2)) .* 2 .- 1\n            @test out1 == out1[1]:out1[end]\n        finally\n            close(oe1)\n            close(oe2)\n        end\n    end\nend","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"","category":"page"},{"location":"tutorials/select/","page":"Select","title":"Select","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/search3/","page":"Example: Google Search 3.0","title":"Example: Google Search 3.0","text":"EditURL = \"https://github.com/tkf/Julio.jl/blob/master/examples/search3.jl\"","category":"page"},{"location":"tutorials/search3/","page":"Example: Google Search 3.0","title":"Example: Google Search 3.0","text":"note: Note\nJulio.jl is still work-in-progress.","category":"page"},{"location":"tutorials/search3/#Google-Search-3.0","page":"Example: Google Search 3.0","title":"Google Search 3.0","text":"","category":"section"},{"location":"tutorials/search3/","page":"Example: Google Search 3.0","title":"Example: Google Search 3.0","text":"using Julio\nusing Julio: Events\nusing ContextManagers: @with, SharedResource","category":"page"},{"location":"tutorials/search3/","page":"Example: Google Search 3.0","title":"Example: Google Search 3.0","text":"This is an example taken from Rob Pike's 2012 talk Go Concurrency Patterns.","category":"page"},{"location":"tutorials/search3/","page":"Example: Google Search 3.0","title":"Example: Google Search 3.0","text":"Avoid timeout (search engine replicas) https://talks.golang.org/2012/concurrency.slide#48","category":"page"},{"location":"tutorials/search3/","page":"Example: Google Search 3.0","title":"Example: Google Search 3.0","text":"replicas is a tuple of callables with the signature query -> promise; e.g., replicas = webs = (web1, web2).","category":"page"},{"location":"tutorials/search3/","page":"Example: Google Search 3.0","title":"Example: Google Search 3.0","text":"first_response!(ie, query::AbstractString, replicas::Tuple) =\n    put!(ie, Julio.select(Events.fetch.(query .|> replicas)...))","category":"page"},{"location":"tutorials/search3/","page":"Example: Google Search 3.0","title":"Example: Google Search 3.0","text":"Google Search 3.0 https://talks.golang.org/2012/concurrency.slide#50","category":"page"},{"location":"tutorials/search3/","page":"Example: Google Search 3.0","title":"Example: Google Search 3.0","text":"function replicated_search(webs, images, videos)\n    query = \"Julio\"\n    results = String[]\n    ie, oe = Julio.channel()\n    try\n        Julio.withtaskgroup() do tg\n            @with(handle = SharedResource(ie)) do\n                Julio.spawn!(first_response!, tg, handle, query, webs)\n                Julio.spawn!(first_response!, tg, handle, query, images)\n                Julio.spawn!(first_response!, tg, handle, query, videos)\n            end\n            Julio.spawn!(tg) do\n                Julio.sleep(0.08)\n                Julio.cancel!(tg)\n            end\n            append!(results, oe)\n            Julio.cancel!(tg)\n        end\n    finally\n        close(oe)\n    end\n    return results\nend","category":"page"},{"location":"tutorials/search3/","page":"Example: Google Search 3.0","title":"Example: Google Search 3.0","text":"Setup code:","category":"page"},{"location":"tutorials/search3/","page":"Example: Google Search 3.0","title":"Example: Google Search 3.0","text":"replicated_search_demo() = with_search_engines(replicated_search)\n\nfunction with_close_hook(f)\n    resources = []\n    function closing(r)\n        push!(resources, r)\n        return r\n    end\n    try\n        f(closing)\n    finally\n        foreach(close, resources)\n    end\nend\n\nfunction spawn_fakesearch!(tg, label, closing)\n    ie, oe = Julio.channel()\n    closing(ie)\n    Julio.spawn!(tg) do\n        try\n            for (query, reply) in oe\n                sleep(rand(0.01:0.01:0.1))\n                reply[] = \"$label result for $query\"\n            end\n        finally\n            close(oe)\n        end\n    end\n    function request(query)\n        reply = Julio.Promise()\n        put!(ie, query => reply)\n        return reply\n    end\n    return request\nend\n\nfunction with_search_engines(f)\n    Julio.withtaskgroup() do tg\n        with_close_hook() do closing\n            web1 = spawn_fakesearch!(tg, \"web1\", closing)\n            web2 = spawn_fakesearch!(tg, \"web2\", closing)\n            image1 = spawn_fakesearch!(tg, \"image1\", closing)\n            image2 = spawn_fakesearch!(tg, \"image2\", closing)\n            video1 = spawn_fakesearch!(tg, \"video1\", closing)\n            video2 = spawn_fakesearch!(tg, \"video2\", closing)\n            f((web1, web2), (image1, image2), (video1, video2))\n        end\n    end\nend\n\nusing Test\n\nfunction test_replicated_search_demo()\n    nok = 0\n    for _ in 1:10\n        results = replicated_search_demo()\n        nok += length(results) == 3\n    end\n    @test nok > 0\nend","category":"page"},{"location":"tutorials/search3/","page":"Example: Google Search 3.0","title":"Example: Google Search 3.0","text":"","category":"page"},{"location":"tutorials/search3/","page":"Example: Google Search 3.0","title":"Example: Google Search 3.0","text":"This page was generated using Literate.jl.","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"EditURL = \"https://github.com/tkf/Julio.jl/blob/master/examples/structured_concurrency.jl\"","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"note: Note\nJulio.jl is still work-in-progress.","category":"page"},{"location":"explanation/structured_concurrency/#Structured-concurrency","page":"Structured concurrencty","title":"Structured concurrency","text":"","category":"section"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"using Julio\nusing Test","category":"page"},{"location":"explanation/structured_concurrency/#black-box","page":"Structured concurrencty","title":"Black box rule","text":"","category":"section"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"In sequential programs, the side-effects of a function are \"done\" by the time the function returns [closure]. However, many concurrent programming paradims do not let us assume such a simple but yet highly useful property. In Notes on structured concurrency, or: Go statement considered harmful — njs blog (See also: Trio: Async concurrency for mere mortals - PyCon 2018 - YouTube), Nathaniel J. Smith called this property the \"black box rule\".","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"[closure]: Programming constructs such as closures, coroutines, and \"methods\" in class-based object oriented programming languages may be considered as mechanisms for \"resuming\" the side-effects. However, they have visible syntax (e.g., function call) for resuming the side-effect. Thus, these constructs still follow the black box rule.","category":"page"},{"location":"explanation/structured_concurrency/#Programming-without-the-black-box-rule","page":"Structured concurrencty","title":"Programming without the black box rule","text":"","category":"section"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"To demonstrate the pain comes with functions that does not follow the black box rule, let us consider the following simple function:","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"function channel_map_unstructured!(f, output, input; ntasks = Threads.nthreads())\n    for _ in 1:ntasks\n        Threads.@spawn for x in input\n            y = f(x)\n            put!(output, y)\n        end\n    end\nend","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"This function channel_map_unstructured! does not follow the black box rule because it does not wait for the spawned tasks; i.e., these \"leaked\" tasks are keep mutating output and input even after channel_map_unstructured! returns.  Programs using such functions like this are very hard to understand.","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"function test_channel_map_unstructured()","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"Suppose we need to combine the result of two kinds of \"computations\" into one output channel (source_channel is defined below):","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"    output = Channel()\n    channel_map_unstructured!(output, source_channel(1:100); ntasks = 10) do x\n        sleep(0.01)\n        2x\n    end\n    channel_map_unstructured!(output, source_channel(1:100); ntasks = 10) do x\n        sleep(0.01)\n        2x + 1\n    end","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"It is tricky to accumulate the result reliably (another disadvantage of unstructured concurrencty).  For this demonstration, we can \"cheat\" since we know the size of the output.","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"    results = []\n    for _ in 1:200\n        push!(results, take!(output))\n    end\n    close(output)","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"Ideally, the program order is reflected in the result. If it were the case, we should see even numbers first and then odd numbers. However, since channel_map_unstructured! violates the black box rule and the \"leaked\" tasks are keep adding results to the output channel, we can't understand the program by looking at the invocations of channel_map_unstructured!.","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"    @test_broken all(iseven, results[1:end÷2])\n    @test_broken all(isodd, results[end÷2+1:end])","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"end","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"(The above example uses a simple utility function source_channel for generating the input source:)","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"function source_channel(xs)\n    ch = Channel(Inf)\n    for x in xs\n        put!(ch, x)\n    end\n    close(ch)\n    return ch\nend","category":"page"},{"location":"explanation/structured_concurrency/#Julio-API-enforces-the-black-box-rule","page":"Structured concurrencty","title":"Julio API enforces the black box rule","text":"","category":"section"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"Julio \"enforces\" the black box rule by providing API such that Julio.spawn! can be called only within a dynamical scope of Julio.withtaskgroup.  Thus, mechanically translating channel_map_unstructured! to use Julio API gives us a function that follows the black box rule.","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"function channel_map_structured!(f, output, input; ntasks = Threads.nthreads())\n    Julio.withtaskgroup() do tg\n        for _ in 1:ntasks\n            Julio.spawn!(tg) do\n                for x in input\n                    y = f(x)\n                    put!(output, y)\n                end\n            end\n        end\n    end\nend\n\nfunction test_channel_map_structured()\n    ie, eh = Julio.queue()\n    try\n        try\n            channel_map_structured!(ie, source_channel(1:100); ntasks = 10) do x\n                sleep(0.01)\n                2x\n            end\n            channel_map_structured!(ie, source_channel(1:100); ntasks = 10) do x\n                sleep(0.01)\n                2x + 1\n            end\n        finally\n            close(ie)\n        end\n        results = collect(eh)\n        @test all(iseven, results[1:end÷2])\n        @test all(isodd, results[end÷2+1:end])\n    finally\n        close(eh)\n    end\nend","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"TODO: explain the nursery passing style","category":"page"},{"location":"explanation/structured_concurrency/#Error-handling","page":"Structured concurrencty","title":"Error handling","text":"","category":"section"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"It is possible to satisfy the black box rule using the Base API:","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"function channel_map_base!(f, output, input; ntasks = Threads.nthreads())\n    @sync for _ in 1:ntasks\n        Threads.@spawn for x in input\n            y = f(x)\n            put!(output, y)\n        end\n    end\nend","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"However, it is problematic when f throws. In the above example, the execution will not be finished until either all items in input are consumed or all tasks throw.","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"function error_on_10(x)\n    x == 10 && error(\"error in one task\")\n    sleep(0.01)\n    return x\nend\n\nfunction test_channel_map_base()\n    output = Channel(Inf)\n    try\n        channel_map_base!(error_on_10, output, source_channel(1:100); ntasks = 10)\n    catch\n    end\n    close(output)\n    results = collect(output)\n    push!(results, 10)\n    sort!(results)\n    @test results == 1:100\nend","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"note: Note\nBase.Experimental.@sync can be used to throw an error as soon as the first task throws. However, it then leaks unfinished tasks; i.e., we can't assume the black box rule anymore.","category":"page"},{"location":"explanation/structured_concurrency/#Manual-concurrent-error-handling-is-hard","page":"Structured concurrencty","title":"Manual concurrent error handling is hard","text":"","category":"section"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"In general, it is hard to implement robust error handling using the Base API. Even though it is possible to do so case-by-case basis, there is no simple mechanism that the users can rely on.  For example, we can introduce an intermediate channel in the above example. This intermediate channel will be closed on error and hence unblock all the tasks. However, this strategy results in a subtle code that obscures the core logic:","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"function channel_map_base2!(f, output, input; ntasks = Threads.nthreads())\n    tmpch = Channel() do ch\n        for y in ch\n            put!(output, y)\n        end\n    end\n    try\n        @sync for _ in 1:ntasks\n            Threads.@spawn try\n                for x in input\n                    y = f(x)\n                    put!(tmpch, y)\n                end\n            catch\n                close(tmpch)\n                rethrow()\n            end\n        end\n    finally\n        close(tmpch)\n    end\nend\n\nfunction test_channel_map_base2()\n    output = Channel(Inf)\n    try\n        channel_map_base2!(error_on_10, output, source_channel(1:100); ntasks = 10)\n    catch\n    end\n    close(output)\n    results = collect(output)\n    @test length(results) < 100\nend","category":"page"},{"location":"explanation/structured_concurrency/#Julio-automates-concurrent-error-handling","page":"Structured concurrencty","title":"Julio automates concurrent error handling","text":"","category":"section"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"When using Julio API, errors are automatically propagated.  In fact, channel_map_structured! defined above already have the desired property:","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"function test_channel_map_structured_error()\n    ie, eh = Julio.queue()\n    try\n        try\n            channel_map_structured!(error_on_10, ie, source_channel(1:100); ntasks = 10)\n        catch\n        finally\n            close(ie)\n        end\n        results = collect(eh)\n        @test length(results) < 100\n    finally\n        close(eh)\n    end\nend","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"For more detailed controll on cancellation, see also: Example: bounding search results","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"","category":"page"},{"location":"explanation/structured_concurrency/","page":"Structured concurrencty","title":"Structured concurrencty","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"EditURL = \"https://github.com/tkf/Julio.jl/blob/master/examples/custom_select.jl\"","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"note: Note\nJulio.jl is still work-in-progress.","category":"page"},{"location":"tutorials/custom_select/#Selecting-on-custom-events","page":"Advanced: Custom select","title":"Selecting on custom events","text":"","category":"section"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"Julio.jl is built on top of Reagents.jl, a framework for writing programs with complex nonblocking algorithms and synchronizations.  In fact, Julia.select is a thin wrapper on top of the choice combinator | defined in Reagents.jl. Therefore, it is possible to define custom synchronization events using Reagents.jl API.","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"using Reagents\nusing Reagents: CAS, Computed, Return, Read, PostCommit\nusing Julio\nusing Julio: Events\nusing Test","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"Let us define a \"leaky\" \"broadcasting\" channel; i.e., \"broadcasting\" in the sense that a put! can be take!n by multiple tasks and \"leaky\" in the sense that the items will be lost if there are no receiver tasks executing take! while the sender is executing put!.","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"struct BroadcastChannel{T,Receivers}\n    eltype::Val{T}\n    lck::Julio.Lock\n    receivers::Receivers\nend\n\nfunction BroadcastChannel{T}() where {T}\n    receivers = typeof(Julio.Promise{T}())[]\n    lck = Julio.Lock()\n    return BroadcastChannel(Val(T), lck, receivers)\nend","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"(We use a lock-based implementation to keep the example simple. It should also be possible to use some nonblocking algorithms.)","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"The receiver requests an item simply by posting a Julio.Promise:","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"(TODO: make it work without touching Julio.Internal)","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"Base.take!(bc::BroadcastChannel{T}) where {T} = Julio.Internal.apply(take!, bc)::T\nfunction Julio.Internal.event(::typeof(take!), bc::BroadcastChannel{T}) where {T}\n    (; lck, receivers) = bc\n    p = Julio.Promise{T}()\n    lock(lck) do\n        filter!(isopen, receivers)\n        push!(receivers, p)\n    end\n    return Reagents.WithNack() do nack\n        # Cleanup in case this event is not selected:\n        Reagents.dissolve(nack ⨟ PostCommit(_ -> close(p)); once = true)\n        Return(nothing)\n    end ⨟ Events.fetch(p)\nend","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"An item is sent to all the receivers registered at the time put! is called:","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"function Base.put!(bc::BroadcastChannel{T}, x) where {T}\n    (; lck, receivers) = bc\n    x = convert(T, x)\n    lock(lck) do\n        for p in receivers\n            Julio.tryput!(p, x)  # tryput! instead of put! to ignore closed promises\n        end\n        empty!(receivers)\n    end\nend","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"Demo:","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"function test_broadcastchannel(; ntasks = 4)\n    bc = BroadcastChannel{Int}()\n    done = Julio.Promise{Nothing}()\n    Julio.withtaskgroup() do tg\n        tasks = map(1:ntasks) do _\n            Julio.spawn!(tg) do\n                local items = Int[]\n                while true\n                    Julio.select(\n                        (fetch, done) => Returns(true),\n                        (take!, bc) => x -> begin\n                            push!(items, x)\n                            false\n                        end,\n                    ) && break\n                end\n                return items\n            end\n        end\n        try\n            for x in 1:2^10\n                put!(bc, x)\n            end\n        finally\n            done[] = nothing\n        end\n        for t in tasks\n            items = fetch(t)\n            @test all(>(0), diff(items))\n        end\n    end\nend","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"","category":"page"},{"location":"tutorials/custom_select/","page":"Advanced: Custom select","title":"Advanced: Custom select","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/api/","page":"API","title":"API","text":"Main._BANNER_","category":"page"},{"location":"reference/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"reference/api/","page":"API","title":"API","text":"","category":"page"},{"location":"reference/api/","page":"API","title":"API","text":"Modules = [Julio]","category":"page"},{"location":"reference/api/#Julio.Julio","page":"API","title":"Julio.Julio","text":"Julio\n\n\n\n\n\n","category":"module"},{"location":"reference/api/#Julio.Events","page":"API","title":"Julio.Events","text":"Julio.Events.f(args...; kwargs...)\n\nJulio.Events.f(args...; kwargs...) creates an event (i.e., an object describing how to execute f(args...; kwargs...)) that can be passed to Julio.select.\n\nExample\n\nUnlike (f, args...) syntax that is also accepted by Julio.select, Events.f(args...) may have some states. For example, Events.sleep(seconds) sets the timeout at the time the event is created and not when it is passed to Julio.select:\n\njulia> using Julio: Julio, Events\n\njulia> Julio.withtaskgroup() do tg\n           Julio.spawn!(tg) do\n               ev = Events.sleep(0.1)  # countdown starts now\n               while true\n                   Julio.select(\n                       ev => Returns(true),  # eventually this event wins\n                       Events.sleep(0) => Returns(false),\n                   ) && break\n               end\n           end\n       end;\n\n\n\n\n\n","category":"constant"},{"location":"reference/api/#Julio.Lock","page":"API","title":"Julio.Lock","text":"Julio.Lock()\n\nCreates a reentrant lock.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Julio.Promise","page":"API","title":"Julio.Promise","text":"Julio.Promise{T}()\nJulio.Promise()\n\nCreate a promise.\n\nA value of type T (or Any if unspecified) can be set once by put!. Calling fetch blocks until put! is called.\n\nThe indexing notation p[] can be used as a synonym for put! and fetch.\n\nExample\n\njulia> using Julio\n\njulia> p = Julio.Promise();\n\njulia> p[] = 111;\n\njulia> p[]\n111\n\njulia> Julio.withtaskgroup() do tg\n           p = Julio.Promise{Int}()\n           Julio.spawn!(tg) do\n               p[] = 222\n           end\n           p[]\n       end\n222\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Julio.cancel!","page":"API","title":"Julio.cancel!","text":"Julio.cancel!(tg)\nJulio.cancel!(scope)\nJulio.cancel!(handle)\n\nCancel a task group tg or cancellation scope scope.\n\nIt can also be used for revoking the handle returned from Julio.oncancel.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Julio.channel","page":"API","title":"Julio.channel","text":"Julio.channel(T::Type = Any) -> (send_endpoint, receive_endpoint)\n\nJulio.channel creates a unbuffered channel and return a pair of send_endpoint and receive_endpoint.\n\nFollowing methods are supported by the channel:\n\nput!(send_endpoint, item::T)\nJulio.tryput!(send_endpoint, item::T) -> success::Bool\ntake!(receive_endpoint) -> item::T\nJulio.maybetake!(receive_endpoint) -> Some(item) or nothing\nclose(send_endpoint)\nclose(receive_endpoint)\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Julio.checkpoint","page":"API","title":"Julio.checkpoint","text":"Julio.checkpoint()\n\nCheck for cancellation signal. It throws when cancellation is required.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Julio.oncancel","page":"API","title":"Julio.oncancel","text":"Julio.oncancel(f, args...) -> handle\n\nRegister a cancellation callback f and its arguments args to the current cancellation scope.  This callback is triggered via Julio.cancel!(tg) or Julio.cancel!(scope).\n\nThe registered callback can be removed by Julio.cancel!(handle).\n\nSee also: Julio.cancel!.\n\nExample\n\njulia> using Julio\n\njulia> Julio.withtaskgroup() do tg\n           Julio.spawn!(tg) do\n               ch = Channel()  # non Julio API\n               Julio.oncancel(close, ch)  # close the channel on cancellation\n               try\n                   take!(ch)  # blocks forever\n               catch\n                   isopen(ch) && rethrow()  # ignore the exception due to `close`\n               end\n           end\n           Julio.cancel!(tg)\n       end;\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Julio.open","page":"API","title":"Julio.open","text":"Julio.open(io::IO; close = false) -> wrapped_io::IO\n\nWrap an IO object into a new IO that is usable via Julio's synchronization API.\n\nJulio.open(x::AbstractCommand, args...)\nJulio.open(x::AbstractString, args...)\n\nSynonym of Julio.open(open(x, args...); close = true).\n\nJulio.open(f, x, args...)\n\nA shorthand for\n\nresource = Julio.open(x, args...)\ntry\n    f(resource)\nfinally\n    close(resource)\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Julio.queue","page":"API","title":"Julio.queue","text":"Julio.queue(T::Type = Any) -> (send_endpoint, receive_endpoint)\n\nSee Julio.channel.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Julio.select","page":"API","title":"Julio.select","text":"Julio.select(ev₁, ev₂, ..., evₙ) -> ansᵢ\n\nSelect and execute one and only one event evᵢ (1 ≤ i ≤ n) and return its result ansᵢ.\n\nAn even has the following format\n\n(f, args...)\n(f, args...) => g\nJulio.Events.f(args...; kwargs...)\nJulio.Events.f(args...; kwargs...) => g\n\nwhere f is a function such as take! and put!, args are their arguments, kwargs are the named arguments, and g is a unary function that receives the output of (f, args...) or Julio.Events.f(args...; kwargs...).  If g is not specified, identity is used instead.\n\nExamples\n\nusing Julio: Events\n\nJulio.select(\n    (Julio.tryput!, send_endpoint, item),\n    (take!, receive_endpoint) => item -> begin\n        println(\"Got: \", item)\n    end,\n    Event.put!(another_send_endpoint, item),\n    Event.readline(io; keep = true) => line -> begin\n        println(\"Read line: \", line)\n    end,\n)\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Julio.shield","page":"API","title":"Julio.shield","text":"Julio.shield(f)\n\nRun f in a special scope where the cancellation signals are blocked.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Julio.spawn!","page":"API","title":"Julio.spawn!","text":"Julio.spawn!(f, tg, args...) -> task\n\nRun a function f with arguments args inside a task managed by the task group tg.\n\nSee Julio.withtaskgroup.\n\nExample\n\njulia> using Julio\n\njulia> send_endpoint, receive_endpoint = Julio.queue();\n\njulia> Julio.withtaskgroup() do tg\n           Julio.spawn!(tg, 111) do x\n               put!(send_endpoint, x)\n           end\n           Julio.spawn!(tg) do\n               @show take!(receive_endpoint)\n           end\n       end;\ntake!(receive_endpoint) = 111\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Julio.stack","page":"API","title":"Julio.stack","text":"Julio.stack(T::Type = Any) -> (send_endpoint, receive_endpoint)\n\nSee Julio.channel.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Julio.withtaskgroup","page":"API","title":"Julio.withtaskgroup","text":"Julio.withtaskgroup(f) -> ans\n\nCreate a task group tg and pass it to the function f of the form tg -> ans.\n\nSee Julio.spawn!.\n\nExample\n\njulia> using Julio\n\njulia> Julio.withtaskgroup() do tg\n           Julio.spawn!(tg) do\n               println(\"hello\")\n           end\n       end;\nhello\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Julio.withtimeout","page":"API","title":"Julio.withtimeout","text":"Julio.withtimeout(f, seconds) -> Some(ans) or nothing\n\nRun f() with timeout seconds.  If it finishes with output value ans before the timeout, return Some(ans).  Return nothing otherwise.\n\nNote that blocking operations must use Julio API for automatic cancellation; Julio.sleep instead of sleep, read(Julio.open(io)) instead of read(io), and so on.  Use Julio. Non-Julio API can be cancelled using Julio.oncancel.\n\nExample\n\njulia> using Julio\n\njulia> Julio.withtimeout(0.1) do\n           Julio.sleep(60)\n       end === nothing  # too slow\ntrue\n\njulia> Julio.withtimeout(60) do\n           Julio.sleep(0.1)\n       end === Some(nothing)  # success\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Julio.yield","page":"API","title":"Julio.yield","text":"Julio.yield()\n\nA shorthand for Julio.checkpoint(); yield().\n\n\n\n\n\n","category":"function"},{"location":"tutorials/happy_eyeballs/","page":"Example: Happy Eyeballs","title":"Example: Happy Eyeballs","text":"EditURL = \"https://github.com/tkf/Julio.jl/blob/master/examples/happy_eyeballs.jl\"","category":"page"},{"location":"tutorials/happy_eyeballs/","page":"Example: Happy Eyeballs","title":"Example: Happy Eyeballs","text":"note: Note\nJulio.jl is still work-in-progress.","category":"page"},{"location":"tutorials/happy_eyeballs/#Example:-Happy-Eyeballs","page":"Example: Happy Eyeballs","title":"Example: Happy Eyeballs","text":"","category":"section"},{"location":"tutorials/happy_eyeballs/","page":"Example: Happy Eyeballs","title":"Example: Happy Eyeballs","text":"using Sockets\nusing Julio\nusing Test","category":"page"},{"location":"tutorials/happy_eyeballs/","page":"Example: Happy Eyeballs","title":"Example: Happy Eyeballs","text":"An implementation of Happy Eyeballs (RFC 8305) https://datatracker.ietf.org/doc/html/rfc8305","category":"page"},{"location":"tutorials/happy_eyeballs/","page":"Example: Happy Eyeballs","title":"Example: Happy Eyeballs","text":"(TODO: verify)","category":"page"},{"location":"tutorials/happy_eyeballs/","page":"Example: Happy Eyeballs","title":"Example: Happy Eyeballs","text":"function happy_eyeballs(host, port; delay = 0.3)\n    addrs = getalladdrinfo(host)\n    winner = Julio.Promise()\n    decided = nothing\n    allsockets = TCPSocket[]\n    Julio.withtaskgroup() do tg\n        issuccess = false\n        closing = Threads.Atomic{Bool}(false)\n        try\n            failureevents = []\n            for ip in addrs\n                failed = Julio.Promise{Nothing}()\n                push!(failureevents, failed)\n                socket = TCPSocket()\n                push!(allsockets, socket)\n                Julio.spawn!(tg) do\n                    try\n                        connect(socket, ip, port)\n                    catch err\n                        if err isa Base.IOError\n                            failed[] = nothing\n                            return\n                        elseif closing[]\n                            return\n                        end\n                        rethrow()\n                    end\n                    Julio.tryput!(winner, socket)\n                end\n                Julio.select(\n                    (fetch, winner) => socket -> begin\n                        decided = socket\n                        true\n                    end,\n                    (fetch, failed) => _ -> false,\n                    (sleep, delay) => _ -> false,\n                ) && break\n            end\n            if decided === nothing\n                for failed in failureevents\n                    Julio.select(\n                        (fetch, winner) => socket -> begin\n                            decided = socket\n                            true\n                        end,\n                        (fetch, failed) => _ -> false,\n                    ) && break\n                end\n            end\n            issuccess = true\n        finally\n            closing[] = true\n            for socket in allsockets\n                if !issuccess || socket !== decided\n                    close(socket)\n                end\n            end\n        end\n    end\n    return decided\nend","category":"page"},{"location":"tutorials/happy_eyeballs/","page":"Example: Happy Eyeballs","title":"Example: Happy Eyeballs","text":"Nathaniel J. Smith - Trio: Async concurrency for mere mortals - PyCon 2018 - YouTube\nTwo Approaches to Structured Concurrency - 250bpm","category":"page"},{"location":"tutorials/happy_eyeballs/","page":"Example: Happy Eyeballs","title":"Example: Happy Eyeballs","text":"function test_happy_eyeballs()\n    socket = happy_eyeballs(\"httpbin.org\", 80)\n    try\n        @test socket isa TCPSocket\n        @test isopen(socket)\n    finally\n        close(socket)\n    end\nend","category":"page"},{"location":"tutorials/happy_eyeballs/","page":"Example: Happy Eyeballs","title":"Example: Happy Eyeballs","text":"","category":"page"},{"location":"tutorials/happy_eyeballs/","page":"Example: Happy Eyeballs","title":"Example: Happy Eyeballs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Julio.jl","title":"Julio.jl","text":"Main._BANNER_","category":"page"},{"location":"#Julio.jl","page":"Julio.jl","title":"Julio.jl","text":"","category":"section"},{"location":"","page":"Julio.jl","title":"Julio.jl","text":"Julio is an implementation of structured concurrency for Julia. It is inspired by Trio and Curio.","category":"page"},{"location":"","page":"Julio.jl","title":"Julio.jl","text":"It is built on top of Reagents.jl, a composable framework for nonblocking and synchronization algorithms influenced by Concurrent ML.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"EditURL = \"https://github.com/tkf/Julio.jl/blob/master/examples/introduction.jl\"","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"note: Note\nJulio.jl is still work-in-progress.","category":"page"},{"location":"tutorials/introduction/#Introduction-to-Julio","page":"Introduction","title":"Introduction to Julio","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"using Julio\nusing Test","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"(Note: Currently there's no macro-based syntactic sugar. This is for making sure all the components are composable during the design process.)","category":"page"},{"location":"tutorials/introduction/#Tasks-and-task-groups","page":"Introduction","title":"Tasks and task groups","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Julio manages tasks in task groups. Spawning a task requires creating a task group first.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"function test_simple_spawn()\n    Julio.withtaskgroup() do tg\n        task = Julio.spawn!(tg) do\n            3 + 4\n        end\n        @test (1 + 2) + fetch(task) == 10\n    end\nend","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"This style is useful when combined with the resource management using the open(...) do idiom (scope-based resource management).  See black box rule for more information.","category":"page"},{"location":"tutorials/introduction/#Channels","page":"Introduction","title":"Channels","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"function test_channel_verbose()\n    Julio.withtaskgroup() do tg","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"A channel can be created using Julio.channel. It returns the endpoints for the send and receive sides.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"        send_endpoint, receive_endpoint = Julio.channel()\n        try\n            Julio.spawn!(tg) do\n                try\n                    for i in 1:10\n                        put!(send_endpoint, i)\n                    end\n                finally\n                    close(send_endpoint)  # signaling that there are no more items\n                end\n            end","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"The following collect(receive_endpoint) continues until the child task calls close(send_endpoint).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"            @test collect(receive_endpoint) == 1:10\n        finally\n            close(receive_endpoint)\n        end","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"    end\nend","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Use a task group to wait for multiple tasks before closing the endpoint:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"function test_channel_open_many_scoped()\n    send_endpoint, receive_endpoint = Julio.channel()\n    local task\n    Julio.withtaskgroup() do tg0\n        task = Julio.spawn!(tg0) do\n            try\n                sort!(collect(receive_endpoint))\n            finally\n                close(receive_endpoint)\n            end\n        end\n        try\n            Julio.withtaskgroup() do tg1\n                for i in 1:10\n                    Julio.spawn!(tg1) do\n                        put!(send_endpoint, i)\n                    end\n                end\n            end\n        finally\n            close(send_endpoint)\n        end\n    end\n    @test fetch(task) == 1:10\nend","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Note that Julio.channel is always unbuffered. Use Julio.queue and Julio.stack for buffered channels.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"function test_queue()\n    send_endpoint, receive_endpoint = Julio.queue()\n    put!(send_endpoint, 111)\n    put!(send_endpoint, 222)\n    @test take!(receive_endpoint) == 111\n    @test take!(receive_endpoint) == 222\nend","category":"page"},{"location":"tutorials/introduction/#Timeout","page":"Introduction","title":"Timeout","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Julio can introduce a timeout for arbitrary code blocks.  The timeout is triggered whenever the code is blocked by a Julia API.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"function test_timeout()\n    send_endpoint, receive_endpoint = Julio.channel()\n    Julio.withtimeout(0.1) do\n        put!(send_endpoint, nothing)  # never completes\n    end\nend","category":"page"},{"location":"tutorials/introduction/#Automatic-cancellation","page":"Introduction","title":"Automatic cancellation","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Julio cancells the tasks within the same task group if one of them (including the parent task) throws an exception.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"function produce!(input)\n    i = 0\n    while true\n        i += 1\n        put!(input, i)\n    end\nend\n\nfunction test_cancellation()\n    send_endpoint, receive_endpoint = Julio.channel()\n    try\n        task = nothing\n        err = try\n            Julio.withtaskgroup() do tg\n                task = Julio.spawn!(tg) do\n                    try\n                        produce!(send_endpoint)\n                    finally\n                        close(send_endpoint)\n                    end\n                end\n                for i in 1:3\n                    @test take!(receive_endpoint) == i\n                end\n                error(\"cancel\")\n            end\n            nothing\n        catch err\n            err\n        end\n        @test err isa Exception\n        @test istaskdone(task)\n    finally\n        close(receive_endpoint)\n    end\nend","category":"page"},{"location":"tutorials/introduction/#man-cancel-scope","page":"Introduction","title":"Manual cancellation","text":"","category":"section"},{"location":"tutorials/introduction/#Cancel-scope","page":"Introduction","title":"Cancel scope","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Cancellation of Julio tasks can also be triggered manually.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"function test_cancel_scope()\n    _, receive_endpoint = Julio.channel()","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"The parts of code that are cancelled together can be managed by Julio.cancelscope:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"    scope = Julio.cancelscope()","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Let's see how it works with a nested task tree:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"    Julio.withtaskgroup() do tg0\n        Julio.spawn!(tg0) do","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"The cancel scope can be installed at different places.  For example, it can be manually opened.  The blocking calls inside the do block now checks the cancellation signal whenever Julio's blocking method is invoked.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"            open(scope) do\n                take!(receive_endpoint)  # blocks\n            end","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"        end  # Julio.spawn!(tg0) do\n        Julio.spawn!(tg0) do","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"The cancel scope can be also be passed to Julio.withtaskgroup to associate the cancellation scope to the tasks managed by it.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"            Julio.withtaskgroup(scope) do tg1\n                Julio.spawn!(tg1) do\n                    take!(receive_endpoint)  # blocks\n                end\n                take!(receive_endpoint)  # blocks\n            end","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"        end  # Julio.spawn!(tg0) do","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Cancellation can be triggered by Julio.cancel!.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"        Julio.cancel!(scope)","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Since the cancellation signal unblocks all the blocking calls take!(receive_endpoint), this code reliably synchronizes all sub-tasks.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"    end  # Julio.withtaskgroup() do tg0\nend","category":"page"},{"location":"tutorials/introduction/#Interop-with-other-cancellation-mechanisms","page":"Introduction","title":"Interop with other cancellation mechanisms","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Julio can be used with other cancellation mechanisms. For example, several Base API supports cancellation by concurrent close on a \"resource\" object (e.g., Base.Channel, Timer, files). We can hook the close call into Julio's cancellation token by calling Julio.onclose(close, resource).","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"function test_cancel_interop()\n    result = @timed try\n        Julio.withtaskgroup() do tg\n            Julio.spawn!(tg) do\n                timer = Timer(60)\n                Julio.oncancel(close, timer)  # call `close(timer)` on cancellation\n                wait(timer)  # this can be interrupted by `close(timer)`\n            end\n            error(\"cancelling\")\n        end\n        false\n    catch\n        true\n    end\n    @test result.value  # terminated by the execption\n    @test result.time < 30  # it didn't wait 60 seconds\nend","category":"page"},{"location":"tutorials/introduction/#Event-selection","page":"Introduction","title":"Event selection","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Julio supports executing one (and exactly one) of synchronizable events. Here, an event means a possibly blocking operations such as taking an item from a channel.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"function test_select()\n    Julio.withtaskgroup() do tg","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Suppose that we have two channels, but only one of them are available:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"        ie1, oe1 = Julio.channel()\n        ie2, oe2 = Julio.channel()\n        Julio.spawn!(tg) do\n            put!(ie1, 111)\n        end","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"We can select an available \"event\" (here, take!) using Julio.select function.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"        selected = nothing\n        Julio.select(\n            (take!, oe1) => item -> begin\n                selected = item  # result of `take!(oe1)`\n            end,\n            (take!, oe2) => item -> begin\n                selected = item  # result of `take!(oe2)` (unreachable)\n            end,\n        )","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Since only oe1 has a task at the input endpoint, take!(oe1) is chosen:","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"        @test selected == 111","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"    end\nend","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Note that Julio.select works for various synchronizable events and not just channels.  See select for more information.","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"This page was generated using Literate.jl.","category":"page"}]
}
